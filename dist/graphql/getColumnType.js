'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequiredColumnArg = undefined;

var _lodash = require('lodash');

var _graphql = require('graphql');

var _types = require('./types.js');

const coerceToNonNullType = type => type instanceof _graphql.GraphQLNonNull ? type : new _graphql.GraphQLNonNull(type);

/**
 * Creates an argument config to be used with `GraphQLFieldConfig` for the
 * given column.
 *
 * @param {Column} column
 * @returns {GraphQLArgumentConfig}
 */
const createRequiredColumnArg = exports.createRequiredColumnArg = column => ({
  description: column.description,
  type: coerceToNonNullType(getColumnGraphqlType(column))
});

/**
 * A map of types where the PostgreSQL type is the key and the GraphQL type is
 * the value.
 *
 * In order to see available PostgreSQL types in your database run the
 * following query:
 *
 * ```sql
 * select typname, oid, typarray from pg_type where typtype = 'b' order by oid;
 * ```
 *
 * Also see the [`pg-types`][1] moduleâ€™s source code to see what types they
 * are parsing.
 *
 * [1]: https://github.com/brianc/node-pg-types
 */
const postgresToGraphQLTypes = new Map([[20, _types.BigIntType], [21, _graphql.GraphQLInt], [23, _graphql.GraphQLInt], [26, _graphql.GraphQLInt], [700, _graphql.GraphQLFloat], [701, _graphql.GraphQLFloat], [16, _graphql.GraphQLBoolean], [1082, _types.DateType], [1114, _types.DateType], [1184, _types.DateType], [600, _types.PointType], [718, _types.CircleType], [1000, new _graphql.GraphQLList(_graphql.GraphQLBoolean)], [1005, new _graphql.GraphQLList(_graphql.GraphQLInt)], [1007, new _graphql.GraphQLList(_graphql.GraphQLInt)], [1028, new _graphql.GraphQLList(_graphql.GraphQLInt)], [1016, new _graphql.GraphQLList(_types.BigIntType)], [1021, new _graphql.GraphQLList(_graphql.GraphQLFloat)], [1022, new _graphql.GraphQLList(_graphql.GraphQLFloat)], [1231, new _graphql.GraphQLList(_graphql.GraphQLFloat)], [1014, new _graphql.GraphQLList(_graphql.GraphQLString)], [1015, new _graphql.GraphQLList(_graphql.GraphQLString)], [1008, new _graphql.GraphQLList(_graphql.GraphQLString)], [1009, new _graphql.GraphQLList(_graphql.GraphQLString)], [1115, new _graphql.GraphQLList(_types.DateType)], [1182, new _graphql.GraphQLList(_types.DateType)], [1185, new _graphql.GraphQLList(_types.DateType)], [1186, _types.IntervalType], [114, _types.JSONType], [3802, _types.JSONType], [199, new _graphql.GraphQLList(_types.JSONType)], [3807, new _graphql.GraphQLList(_types.JSONType)], [2951, new _graphql.GraphQLList(_graphql.GraphQLString)], [791, new _graphql.GraphQLList(_graphql.GraphQLString)], [1183, new _graphql.GraphQLList(_graphql.GraphQLString)], [1700, _graphql.GraphQLFloat], [2950, _types.UUIDType], [18, _graphql.GraphQLString], [25, _graphql.GraphQLString], [1043, _graphql.GraphQLString]]);

/**
* Gets a GraphQL type for a PostgreSQL type.
*
* @param {Column} column
* @returns {GraphQLType}
*/
const getColumnEnumType = (0, _lodash.memoize)(enum_ => {
  return new _graphql.GraphQLEnumType({
    name: (0, _lodash.upperFirst)((0, _lodash.camelCase)(enum_.name)),
    description: enum_.description,
    values: (0, _lodash.fromPairs)(enum_.variants.map(variant => [(0, _lodash.toUpper)((0, _lodash.snakeCase)(variant)), {
      value: variant
    }]))
  });
}, enum_ => {
  return enum_.name;
});

const getColumnGraphqlType = (0, _lodash.memoize)(column => {
  const wrapType = type => column.isNullable ? type : new _graphql.GraphQLNonNull(type);
  const internalType = postgresToGraphQLTypes.get(column.type);

  if (column.isPrimaryKey && internalType === _graphql.GraphQLString) return wrapType(_graphql.GraphQLID);

  // If our map has a `GraphQLType`, use it.
  if (internalType) return wrapType(internalType);

  // If the column has an enum type, we need to create a `GraphQLEnumType`.
  const enum_ = column.getEnum();
  if (enum_) return wrapType(getColumnEnumType(enum_));

  // Otherwise, just return `GraphQLString`.
  return wrapType(_graphql.GraphQLString);
});

exports['default'] = getColumnGraphqlType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncmFwaHFsL2dldENvbHVtblR5cGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUVBOztBQUdBLE1BQU0sc0JBQXNCLFFBQVMsMENBQWlDLElBQWpDLEdBQXdDLDRCQUFtQixJQUFuQixDQUE3RTs7Ozs7Ozs7O0FBU08sTUFBTSw0REFBMEIsV0FBVztBQUNoRCxlQUFhLE9BQU8sV0FENEI7QUFFaEQsUUFBTSxvQkFBb0IscUJBQXFCLE1BQXJCLENBQXBCO0FBRjBDLENBQVgsQ0FBaEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCUCxNQUFNLHlCQUF5QixJQUFJLEdBQUosQ0FBUSxDQUNyQyxDQUFDLEVBQUQsb0JBRHFDLEVBRXJDLENBQUMsRUFBRCxzQkFGcUMsRUFHckMsQ0FBQyxFQUFELHNCQUhxQyxFQUlyQyxDQUFDLEVBQUQsc0JBSnFDLEVBS3JDLENBQUMsR0FBRCx3QkFMcUMsRUFNckMsQ0FBQyxHQUFELHdCQU5xQyxFQU9yQyxDQUFDLEVBQUQsMEJBUHFDLEVBUXJDLENBQUMsSUFBRCxrQkFScUMsRUFTckMsQ0FBQyxJQUFELGtCQVRxQyxFQVVyQyxDQUFDLElBQUQsa0JBVnFDLEVBV3JDLENBQUMsR0FBRCxtQkFYcUMsRUFZckMsQ0FBQyxHQUFELG9CQVpxQyxFQWFyQyxDQUFDLElBQUQsRUFBTyxpREFBUCxDQWJxQyxFQWNyQyxDQUFDLElBQUQsRUFBTyw2Q0FBUCxDQWRxQyxFQWVyQyxDQUFDLElBQUQsRUFBTyw2Q0FBUCxDQWZxQyxFQWdCckMsQ0FBQyxJQUFELEVBQU8sNkNBQVAsQ0FoQnFDLEVBaUJyQyxDQUFDLElBQUQsRUFBTywyQ0FBUCxDQWpCcUMsRUFrQnJDLENBQUMsSUFBRCxFQUFPLCtDQUFQLENBbEJxQyxFQW1CckMsQ0FBQyxJQUFELEVBQU8sK0NBQVAsQ0FuQnFDLEVBb0JyQyxDQUFDLElBQUQsRUFBTywrQ0FBUCxDQXBCcUMsRUFxQnJDLENBQUMsSUFBRCxFQUFPLGdEQUFQLENBckJxQyxFQXNCckMsQ0FBQyxJQUFELEVBQU8sZ0RBQVAsQ0F0QnFDLEVBdUJyQyxDQUFDLElBQUQsRUFBTyxnREFBUCxDQXZCcUMsRUF3QnJDLENBQUMsSUFBRCxFQUFPLGdEQUFQLENBeEJxQyxFQXlCckMsQ0FBQyxJQUFELEVBQU8seUNBQVAsQ0F6QnFDLEVBMEJyQyxDQUFDLElBQUQsRUFBTyx5Q0FBUCxDQTFCcUMsRUEyQnJDLENBQUMsSUFBRCxFQUFPLHlDQUFQLENBM0JxQyxFQTRCckMsQ0FBQyxJQUFELHNCQTVCcUMsRUE2QnJDLENBQUMsR0FBRCxrQkE3QnFDLEVBOEJyQyxDQUFDLElBQUQsa0JBOUJxQyxFQStCckMsQ0FBQyxHQUFELEVBQU0seUNBQU4sQ0EvQnFDLEVBZ0NyQyxDQUFDLElBQUQsRUFBTyx5Q0FBUCxDQWhDcUMsRUFpQ3JDLENBQUMsSUFBRCxFQUFPLGdEQUFQLENBakNxQyxFQWtDckMsQ0FBQyxHQUFELEVBQU0sZ0RBQU4sQ0FsQ3FDLEVBbUNyQyxDQUFDLElBQUQsRUFBTyxnREFBUCxDQW5DcUMsRUFvQ3JDLENBQUMsSUFBRCx3QkFwQ3FDLEVBcUNyQyxDQUFDLElBQUQsa0JBckNxQyxFQXNDckMsQ0FBQyxFQUFELHlCQXRDcUMsRUF1Q3JDLENBQUMsRUFBRCx5QkF2Q3FDLEVBd0NyQyxDQUFDLElBQUQseUJBeENxQyxDQUFSLENBQS9COzs7Ozs7OztBQWlEQSxNQUFNLG9CQUFvQixxQkFBUSxTQUFTO0FBQ3pDLFNBQU8sNkJBQW9CO0FBQ3pCLFVBQU0sd0JBQVcsdUJBQVUsTUFBTSxJQUFoQixDQUFYLENBRG1CO0FBRXpCLGlCQUFhLE1BQU0sV0FGTTtBQUd6QixZQUFRLHVCQUNOLE1BQU0sUUFBTixDQUNHLEdBREgsQ0FDTyxXQUFXLENBQUMscUJBQVEsdUJBQVUsT0FBVixDQUFSLENBQUQsRUFBOEI7QUFDNUMsYUFBTztBQURxQyxLQUE5QixDQURsQixDQURNO0FBSGlCLEdBQXBCLENBQVA7QUFVRCxDQVh5QixFQVd2QixTQUFTO0FBQ1YsU0FBTyxNQUFNLElBQWI7QUFDRCxDQWJ5QixDQUExQjs7QUFlQSxNQUFNLHVCQUF1QixxQkFBUSxVQUFVO0FBQzdDLFFBQU0sV0FBVyxRQUFTLE9BQU8sVUFBUCxHQUFvQixJQUFwQixHQUEyQiw0QkFBbUIsSUFBbkIsQ0FBckQ7QUFDQSxRQUFNLGVBQWUsdUJBQXVCLEdBQXZCLENBQTJCLE9BQU8sSUFBbEMsQ0FBckI7O0FBRUEsTUFBSSxPQUFPLFlBQVAsSUFBdUIsdUNBQTNCLEVBQ0UsT0FBTyw0QkFBUDs7O0FBR0YsTUFBSSxZQUFKLEVBQ0UsT0FBTyxTQUFTLFlBQVQsQ0FBUDs7O0FBR0YsUUFBTSxRQUFRLE9BQU8sT0FBUCxFQUFkO0FBQ0EsTUFBSSxLQUFKLEVBQ0UsT0FBTyxTQUFTLGtCQUFrQixLQUFsQixDQUFULENBQVA7OztBQUdGLFNBQU8sZ0NBQVA7QUFDRCxDQWxCNEIsQ0FBN0I7O3FCQW9CZSxvQiIsImZpbGUiOiJnZXRDb2x1bW5UeXBlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVtb2l6ZSwgZnJvbVBhaXJzLCB1cHBlckZpcnN0LCBjYW1lbENhc2UsIHNuYWtlQ2FzZSwgdG9VcHBlciB9IGZyb20gJ2xvZGFzaCdcblxuaW1wb3J0IHsgR3JhcGhRTEJvb2xlYW4sIEdyYXBoUUxJbnQsIEdyYXBoUUxGbG9hdCwgR3JhcGhRTFN0cmluZywgR3JhcGhRTExpc3QsIEdyYXBoUUxOb25OdWxsLCBHcmFwaFFMRW51bVR5cGUsIEdyYXBoUUxJRCB9IGZyb20gJ2dyYXBocWwnXG5cbmltcG9ydCB7IERhdGVUeXBlLCBCaWdJbnRUeXBlLCBQb2ludFR5cGUsIENpcmNsZVR5cGUsIEludGVydmFsVHlwZSwgSlNPTlR5cGUsIFVVSURUeXBlLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5jb25zdCBjb2VyY2VUb05vbk51bGxUeXBlID0gdHlwZSA9PiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxOb25OdWxsID8gdHlwZSA6IG5ldyBHcmFwaFFMTm9uTnVsbCh0eXBlKSlcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFyZ3VtZW50IGNvbmZpZyB0byBiZSB1c2VkIHdpdGggYEdyYXBoUUxGaWVsZENvbmZpZ2AgZm9yIHRoZVxuICogZ2l2ZW4gY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7Q29sdW1ufSBjb2x1bW5cbiAqIEByZXR1cm5zIHtHcmFwaFFMQXJndW1lbnRDb25maWd9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXF1aXJlZENvbHVtbkFyZyA9IGNvbHVtbiA9PiAoe1xuICBkZXNjcmlwdGlvbjogY29sdW1uLmRlc2NyaXB0aW9uLFxuICB0eXBlOiBjb2VyY2VUb05vbk51bGxUeXBlKGdldENvbHVtbkdyYXBocWxUeXBlKGNvbHVtbikpLFxufSlcblxuLyoqXG4gKiBBIG1hcCBvZiB0eXBlcyB3aGVyZSB0aGUgUG9zdGdyZVNRTCB0eXBlIGlzIHRoZSBrZXkgYW5kIHRoZSBHcmFwaFFMIHR5cGUgaXNcbiAqIHRoZSB2YWx1ZS5cbiAqXG4gKiBJbiBvcmRlciB0byBzZWUgYXZhaWxhYmxlIFBvc3RncmVTUUwgdHlwZXMgaW4geW91ciBkYXRhYmFzZSBydW4gdGhlXG4gKiBmb2xsb3dpbmcgcXVlcnk6XG4gKlxuICogYGBgc3FsXG4gKiBzZWxlY3QgdHlwbmFtZSwgb2lkLCB0eXBhcnJheSBmcm9tIHBnX3R5cGUgd2hlcmUgdHlwdHlwZSA9ICdiJyBvcmRlciBieSBvaWQ7XG4gKiBgYGBcbiAqXG4gKiBBbHNvIHNlZSB0aGUgW2BwZy10eXBlc2BdWzFdIG1vZHVsZeKAmXMgc291cmNlIGNvZGUgdG8gc2VlIHdoYXQgdHlwZXMgdGhleVxuICogYXJlIHBhcnNpbmcuXG4gKlxuICogWzFdOiBodHRwczovL2dpdGh1Yi5jb20vYnJpYW5jL25vZGUtcGctdHlwZXNcbiAqL1xuY29uc3QgcG9zdGdyZXNUb0dyYXBoUUxUeXBlcyA9IG5ldyBNYXAoW1xuICBbMjAsIEJpZ0ludFR5cGVdLFxuICBbMjEsIEdyYXBoUUxJbnRdLFxuICBbMjMsIEdyYXBoUUxJbnRdLFxuICBbMjYsIEdyYXBoUUxJbnRdLFxuICBbNzAwLCBHcmFwaFFMRmxvYXRdLFxuICBbNzAxLCBHcmFwaFFMRmxvYXRdLFxuICBbMTYsIEdyYXBoUUxCb29sZWFuXSxcbiAgWzEwODIsIERhdGVUeXBlXSxcbiAgWzExMTQsIERhdGVUeXBlXSxcbiAgWzExODQsIERhdGVUeXBlXSxcbiAgWzYwMCwgUG9pbnRUeXBlXSxcbiAgWzcxOCwgQ2lyY2xlVHlwZV0sXG4gIFsxMDAwLCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTEJvb2xlYW4pXSxcbiAgWzEwMDUsIG5ldyBHcmFwaFFMTGlzdChHcmFwaFFMSW50KV0sXG4gIFsxMDA3LCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTEludCldLFxuICBbMTAyOCwgbmV3IEdyYXBoUUxMaXN0KEdyYXBoUUxJbnQpXSxcbiAgWzEwMTYsIG5ldyBHcmFwaFFMTGlzdChCaWdJbnRUeXBlKV0sXG4gIFsxMDIxLCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTEZsb2F0KV0sXG4gIFsxMDIyLCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTEZsb2F0KV0sXG4gIFsxMjMxLCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTEZsb2F0KV0sXG4gIFsxMDE0LCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTFN0cmluZyldLFxuICBbMTAxNSwgbmV3IEdyYXBoUUxMaXN0KEdyYXBoUUxTdHJpbmcpXSxcbiAgWzEwMDgsIG5ldyBHcmFwaFFMTGlzdChHcmFwaFFMU3RyaW5nKV0sXG4gIFsxMDA5LCBuZXcgR3JhcGhRTExpc3QoR3JhcGhRTFN0cmluZyldLFxuICBbMTExNSwgbmV3IEdyYXBoUUxMaXN0KERhdGVUeXBlKV0sXG4gIFsxMTgyLCBuZXcgR3JhcGhRTExpc3QoRGF0ZVR5cGUpXSxcbiAgWzExODUsIG5ldyBHcmFwaFFMTGlzdChEYXRlVHlwZSldLFxuICBbMTE4NiwgSW50ZXJ2YWxUeXBlXSxcbiAgWzExNCwgSlNPTlR5cGVdLFxuICBbMzgwMiwgSlNPTlR5cGVdLFxuICBbMTk5LCBuZXcgR3JhcGhRTExpc3QoSlNPTlR5cGUpXSxcbiAgWzM4MDcsIG5ldyBHcmFwaFFMTGlzdChKU09OVHlwZSldLFxuICBbMjk1MSwgbmV3IEdyYXBoUUxMaXN0KEdyYXBoUUxTdHJpbmcpXSxcbiAgWzc5MSwgbmV3IEdyYXBoUUxMaXN0KEdyYXBoUUxTdHJpbmcpXSxcbiAgWzExODMsIG5ldyBHcmFwaFFMTGlzdChHcmFwaFFMU3RyaW5nKV0sXG4gIFsxNzAwLCBHcmFwaFFMRmxvYXRdLFxuICBbMjk1MCwgVVVJRFR5cGVdLFxuICBbMTgsIEdyYXBoUUxTdHJpbmddLFxuICBbMjUsIEdyYXBoUUxTdHJpbmddLFxuICBbMTA0MywgR3JhcGhRTFN0cmluZ10sXG5dKVxuXG4vKipcbiogR2V0cyBhIEdyYXBoUUwgdHlwZSBmb3IgYSBQb3N0Z3JlU1FMIHR5cGUuXG4qXG4qIEBwYXJhbSB7Q29sdW1ufSBjb2x1bW5cbiogQHJldHVybnMge0dyYXBoUUxUeXBlfVxuKi9cbmNvbnN0IGdldENvbHVtbkVudW1UeXBlID0gbWVtb2l6ZShlbnVtXyA9PiB7XG4gIHJldHVybiBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICBuYW1lOiB1cHBlckZpcnN0KGNhbWVsQ2FzZShlbnVtXy5uYW1lKSksXG4gICAgZGVzY3JpcHRpb246IGVudW1fLmRlc2NyaXB0aW9uLFxuICAgIHZhbHVlczogZnJvbVBhaXJzKFxuICAgICAgZW51bV8udmFyaWFudHNcbiAgICAgICAgLm1hcCh2YXJpYW50ID0+IFt0b1VwcGVyKHNuYWtlQ2FzZSh2YXJpYW50KSksIHtcbiAgICAgICAgICB2YWx1ZTogdmFyaWFudFxuICAgICAgICB9XSlcbiAgICApLFxuICB9KVxufSwgZW51bV8gPT4ge1xuICByZXR1cm4gZW51bV8ubmFtZVxufSlcblxuY29uc3QgZ2V0Q29sdW1uR3JhcGhxbFR5cGUgPSBtZW1vaXplKGNvbHVtbiA9PiB7XG4gIGNvbnN0IHdyYXBUeXBlID0gdHlwZSA9PiAoY29sdW1uLmlzTnVsbGFibGUgPyB0eXBlIDogbmV3IEdyYXBoUUxOb25OdWxsKHR5cGUpKVxuICBjb25zdCBpbnRlcm5hbFR5cGUgPSBwb3N0Z3Jlc1RvR3JhcGhRTFR5cGVzLmdldChjb2x1bW4udHlwZSlcblxuICBpZiAoY29sdW1uLmlzUHJpbWFyeUtleSAmJiBpbnRlcm5hbFR5cGUgPT09IEdyYXBoUUxTdHJpbmcpXG4gICAgcmV0dXJuIHdyYXBUeXBlKEdyYXBoUUxJRClcblxuICAvLyBJZiBvdXIgbWFwIGhhcyBhIGBHcmFwaFFMVHlwZWAsIHVzZSBpdC5cbiAgaWYgKGludGVybmFsVHlwZSlcbiAgICByZXR1cm4gd3JhcFR5cGUoaW50ZXJuYWxUeXBlKVxuXG4gIC8vIElmIHRoZSBjb2x1bW4gaGFzIGFuIGVudW0gdHlwZSwgd2UgbmVlZCB0byBjcmVhdGUgYSBgR3JhcGhRTEVudW1UeXBlYC5cbiAgY29uc3QgZW51bV8gPSBjb2x1bW4uZ2V0RW51bSgpXG4gIGlmIChlbnVtXylcbiAgICByZXR1cm4gd3JhcFR5cGUoZ2V0Q29sdW1uRW51bVR5cGUoZW51bV8pKVxuXG4gIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYEdyYXBoUUxTdHJpbmdgLlxuICByZXR1cm4gd3JhcFR5cGUoR3JhcGhRTFN0cmluZylcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGdldENvbHVtbkdyYXBocWxUeXBlXG4iXX0=